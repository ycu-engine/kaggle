"""
This type stub file was generated by pyright.
"""

from textwrap import dedent
from ._decorators import _deprecate_positional_args

"""Plotting functions for linear models (broadly construed)."""
class _LinearPlotter(object):
    """Base class for plotting relational data in tidy format.

    To get anything useful done you'll have to inherit from this, but setup
    code that can be abstracted out should be put here.

    """
    def establish_variables(self, data, **kws):
        """Extract variables from data or use directly."""
        ...
    
    def dropna(self, *vars):
        """Remove observations with missing data."""
        ...
    
    def plot(self, ax):
        ...
    


class _RegressionPlotter(_LinearPlotter):
    """Plotter for numeric independent variables with regression model.

    This does the computations and drawing for the `regplot` function, and
    is thus also used indirectly by `lmplot`.
    """
    def __init__(self, x, y, data=..., x_estimator=..., x_bins=..., x_ci=..., scatter=..., fit_reg=..., ci=..., n_boot=..., units=..., seed=..., order=..., logistic=..., lowess=..., robust=..., logx=..., x_partial=..., y_partial=..., truncate=..., dropna=..., x_jitter=..., y_jitter=..., color=..., label=...) -> None:
        ...
    
    @property
    def scatter_data(self):
        """Data where each observation is a point."""
        ...
    
    @property
    def estimate_data(self):
        """Data with a point estimate and CI for each discrete x value."""
        ...
    
    def fit_regression(self, ax=..., x_range=..., grid=...):
        """Fit the regression model."""
        ...
    
    def fit_fast(self, grid):
        """Low-level regression and prediction using linear algebra."""
        ...
    
    def fit_poly(self, grid, order):
        """Regression using numpy polyfit for higher-order trends."""
        ...
    
    def fit_statsmodels(self, grid, model, **kwargs):
        """More general regression function using statsmodels objects."""
        ...
    
    def fit_lowess(self):
        """Fit a locally-weighted regression, which returns its own grid."""
        ...
    
    def fit_logx(self, grid):
        """Fit the model in log-space."""
        ...
    
    def bin_predictor(self, bins):
        """Discretize a predictor by assigning value to closest bin."""
        ...
    
    def regress_out(self, a, b):
        """Regress b from a keeping a's original mean."""
        ...
    
    def plot(self, ax, scatter_kws, line_kws):
        """Draw the full plot."""
        ...
    
    def scatterplot(self, ax, kws):
        """Draw the data."""
        ...
    
    def lineplot(self, ax, kws):
        """Draw the model."""
        ...
    


_regression_docs = dict(model_api=dedent("""\
    There are a number of mutually exclusive options for estimating the
    regression model. See the :ref:`tutorial <regression_tutorial>` for more
    information.\
    """), regplot_vs_lmplot=dedent("""\
    The :func:`regplot` and :func:`lmplot` functions are closely related, but
    the former is an axes-level function while the latter is a figure-level
    function that combines :func:`regplot` and :class:`FacetGrid`.\
    """), x_estimator=dedent("""\
    x_estimator : callable that maps vector -> scalar, optional
        Apply this function to each unique value of ``x`` and plot the
        resulting estimate. This is useful when ``x`` is a discrete variable.
        If ``x_ci`` is given, this estimate will be bootstrapped and a
        confidence interval will be drawn.\
    """), x_bins=dedent("""\
    x_bins : int or vector, optional
        Bin the ``x`` variable into discrete bins and then estimate the central
        tendency and a confidence interval. This binning only influences how
        the scatterplot is drawn; the regression is still fit to the original
        data.  This parameter is interpreted either as the number of
        evenly-sized (not necessary spaced) bins or the positions of the bin
        centers. When this parameter is used, it implies that the default of
        ``x_estimator`` is ``numpy.mean``.\
    """), x_ci=dedent("""\
    x_ci : "ci", "sd", int in [0, 100] or None, optional
        Size of the confidence interval used when plotting a central tendency
        for discrete values of ``x``. If ``"ci"``, defer to the value of the
        ``ci`` parameter. If ``"sd"``, skip bootstrapping and show the
        standard deviation of the observations in each bin.\
    """), scatter=dedent("""\
    scatter : bool, optional
        If ``True``, draw a scatterplot with the underlying observations (or
        the ``x_estimator`` values).\
    """), fit_reg=dedent("""\
    fit_reg : bool, optional
        If ``True``, estimate and plot a regression model relating the ``x``
        and ``y`` variables.\
    """), ci=dedent("""\
    ci : int in [0, 100] or None, optional
        Size of the confidence interval for the regression estimate. This will
        be drawn using translucent bands around the regression line. The
        confidence interval is estimated using a bootstrap; for large
        datasets, it may be advisable to avoid that computation by setting
        this parameter to None.\
    """), n_boot=dedent("""\
    n_boot : int, optional
        Number of bootstrap resamples used to estimate the ``ci``. The default
        value attempts to balance time and stability; you may want to increase
        this value for "final" versions of plots.\
    """), units=dedent("""\
    units : variable name in ``data``, optional
        If the ``x`` and ``y`` observations are nested within sampling units,
        those can be specified here. This will be taken into account when
        computing the confidence intervals by performing a multilevel bootstrap
        that resamples both units and observations (within unit). This does not
        otherwise influence how the regression is estimated or drawn.\
    """), seed=dedent("""\
    seed : int, numpy.random.Generator, or numpy.random.RandomState, optional
        Seed or random number generator for reproducible bootstrapping.\
    """), order=dedent("""\
    order : int, optional
        If ``order`` is greater than 1, use ``numpy.polyfit`` to estimate a
        polynomial regression.\
    """), logistic=dedent("""\
    logistic : bool, optional
        If ``True``, assume that ``y`` is a binary variable and use
        ``statsmodels`` to estimate a logistic regression model. Note that this
        is substantially more computationally intensive than linear regression,
        so you may wish to decrease the number of bootstrap resamples
        (``n_boot``) or set ``ci`` to None.\
    """), lowess=dedent("""\
    lowess : bool, optional
        If ``True``, use ``statsmodels`` to estimate a nonparametric lowess
        model (locally weighted linear regression). Note that confidence
        intervals cannot currently be drawn for this kind of model.\
    """), robust=dedent("""\
    robust : bool, optional
        If ``True``, use ``statsmodels`` to estimate a robust regression. This
        will de-weight outliers. Note that this is substantially more
        computationally intensive than standard linear regression, so you may
        wish to decrease the number of bootstrap resamples (``n_boot``) or set
        ``ci`` to None.\
    """), logx=dedent("""\
    logx : bool, optional
        If ``True``, estimate a linear regression of the form y ~ log(x), but
        plot the scatterplot and regression model in the input space. Note that
        ``x`` must be positive for this to work.\
    """), xy_partial=dedent("""\
    {x,y}_partial : strings in ``data`` or matrices
        Confounding variables to regress out of the ``x`` or ``y`` variables
        before plotting.\
    """), truncate=dedent("""\
    truncate : bool, optional
        If ``True``, the regression line is bounded by the data limits. If
        ``False``, it extends to the ``x`` axis limits.
    """), xy_jitter=dedent("""\
    {x,y}_jitter : floats, optional
        Add uniform random noise of this size to either the ``x`` or ``y``
        variables. The noise is added to a copy of the data after fitting the
        regression, and only influences the look of the scatterplot. This can
        be helpful when plotting variables that take discrete values.\
    """), scatter_line_kws=dedent("""\
    {scatter,line}_kws : dictionaries
        Additional keyword arguments to pass to ``plt.scatter`` and
        ``plt.plot``.\
    """))
@_deprecate_positional_args
def lmplot(*, x=..., y=..., data=..., hue=..., col=..., row=..., palette=..., col_wrap=..., height=..., aspect=..., markers=..., sharex=..., sharey=..., hue_order=..., col_order=..., row_order=..., legend=..., legend_out=..., x_estimator=..., x_bins=..., x_ci=..., scatter=..., fit_reg=..., ci=..., n_boot=..., units=..., seed=..., order=..., logistic=..., lowess=..., robust=..., logx=..., x_partial=..., y_partial=..., truncate=..., x_jitter=..., y_jitter=..., scatter_kws=..., line_kws=..., size=...):
    ...

@_deprecate_positional_args
def regplot(*, x=..., y=..., data=..., x_estimator=..., x_bins=..., x_ci=..., scatter=..., fit_reg=..., ci=..., n_boot=..., units=..., seed=..., order=..., logistic=..., lowess=..., robust=..., logx=..., x_partial=..., y_partial=..., truncate=..., dropna=..., x_jitter=..., y_jitter=..., label=..., color=..., marker=..., scatter_kws=..., line_kws=..., ax=...):
    ...

@_deprecate_positional_args
def residplot(*, x=..., y=..., data=..., lowess=..., x_partial=..., y_partial=..., order=..., robust=..., dropna=..., label=..., color=..., scatter_kws=..., line_kws=..., ax=...):
    """Plot the residuals of a linear regression.

    This function will regress y on x (possibly as a robust or polynomial
    regression) and then draw a scatterplot of the residuals. You can
    optionally fit a lowess smoother to the residual plot, which can
    help in determining if there is structure to the residuals.

    Parameters
    ----------
    x : vector or string
        Data or column name in `data` for the predictor variable.
    y : vector or string
        Data or column name in `data` for the response variable.
    data : DataFrame, optional
        DataFrame to use if `x` and `y` are column names.
    lowess : boolean, optional
        Fit a lowess smoother to the residual scatterplot.
    {x, y}_partial : matrix or string(s) , optional
        Matrix with same first dimension as `x`, or column name(s) in `data`.
        These variables are treated as confounding and are removed from
        the `x` or `y` variables before plotting.
    order : int, optional
        Order of the polynomial to fit when calculating the residuals.
    robust : boolean, optional
        Fit a robust linear regression when calculating the residuals.
    dropna : boolean, optional
        If True, ignore observations with missing data when fitting and
        plotting.
    label : string, optional
        Label that will be used in any plot legends.
    color : matplotlib color, optional
        Color to use for all elements of the plot.
    {scatter, line}_kws : dictionaries, optional
        Additional keyword arguments passed to scatter() and plot() for drawing
        the components of the plot.
    ax : matplotlib axis, optional
        Plot into this axis, otherwise grab the current axis or make a new
        one if not existing.

    Returns
    -------
    ax: matplotlib axes
        Axes with the regression plot.

    See Also
    --------
    regplot : Plot a simple linear regression model.
    jointplot : Draw a :func:`residplot` with univariate marginal distributions
                (when used with ``kind="resid"``).

    """
    ...

